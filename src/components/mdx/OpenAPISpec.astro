---
/**
 * OpenAPISpec - Render API documentation from an OpenAPI specification
 * Automatically generates endpoint documentation from a spec file
 *
 * Usage:
 * <OpenAPISpec spec={openApiData} />
 *
 * Or with filtering:
 * <OpenAPISpec spec={openApiData} tag="users" />
 */
import APIEndpoint from './APIEndpoint.astro';
import ParamTable from './ParamTable.astro';
import Param from './Param.astro';
import ResponseField from './ResponseField.astro';
import APIPlayground from './APIPlayground.astro';
import Icon from '../Icon.astro';

import type { ParsedOpenAPI, APIEndpoint as APIEndpointType, APIParameter } from '../../utils/openapi';

interface Props {
  spec: ParsedOpenAPI;
  tag?: string;
  showPlayground?: boolean;
  baseUrl?: string;
}

const { spec, tag, showPlayground = true, baseUrl } = Astro.props;

// Filter endpoints by tag if provided
let endpoints = spec.endpoints;
if (tag) {
  endpoints = endpoints.filter(e => e.tags?.includes(tag));
}

// Group endpoints by tag
const groupedEndpoints = new Map<string, APIEndpointType[]>();
for (const endpoint of endpoints) {
  const endpointTag = endpoint.tags?.[0] || 'Other';
  if (!groupedEndpoints.has(endpointTag)) {
    groupedEndpoints.set(endpointTag, []);
  }
  groupedEndpoints.get(endpointTag)!.push(endpoint);
}

// Determine auth type from security
function getAuthType(endpoint: APIEndpointType): "bearer" | "api-key" | "basic" | "none" {
  if (!endpoint.security || endpoint.security.length === 0) return "none";
  // Simple detection - in practice you'd check the security schemes
  return "bearer";
}

// Get schema type as string
function getSchemaType(schema: any): string {
  if (!schema) return 'any';
  if (schema.type === 'array' && schema.items) {
    return `${getSchemaType(schema.items)}[]`;
  }
  return schema.type || 'object';
}

// Group parameters by location
function groupParameters(params: APIParameter[] = []) {
  return {
    path: params.filter(p => p.in === 'path'),
    query: params.filter(p => p.in === 'query'),
    header: params.filter(p => p.in === 'header'),
    cookie: params.filter(p => p.in === 'cookie'),
  };
}

const serverUrl = baseUrl || spec.servers?.[0]?.url || '';
---

<div class="openapi-spec not-prose">
  <!-- API Info Header -->
  <div class="spec-header">
    <div class="spec-info">
      <h1 class="spec-title">{spec.info.title}</h1>
      <span class="spec-version">v{spec.info.version}</span>
    </div>
    {spec.info.description && (
      <p class="spec-description">{spec.info.description}</p>
    )}
    {serverUrl && (
      <div class="spec-server">
        <Icon name="lucide:server" size={14} />
        <code>{serverUrl}</code>
      </div>
    )}
  </div>

  <!-- Endpoints by Tag -->
  {Array.from(groupedEndpoints.entries()).map(([tagName, tagEndpoints]) => (
    <div class="endpoint-group">
      <h2 class="group-title">
        <Icon name="lucide:folder" size={18} />
        {tagName}
      </h2>

      {tagEndpoints.map((endpoint) => {
        const paramGroups = groupParameters(endpoint.parameters);
        const auth = getAuthType(endpoint);
        const successResponse = endpoint.responses?.['200'] || endpoint.responses?.['201'];
        const requestContent = endpoint.requestBody?.content?.['application/json'];

        return (
          <div class="endpoint-wrapper">
            <APIEndpoint
              method={endpoint.method as any}
              path={endpoint.path}
              description={endpoint.summary || endpoint.description}
              deprecated={false}
              auth={auth}
              baseUrl={serverUrl}
            >
              <!-- Path Parameters -->
              {paramGroups.path.length > 0 && (
                <ParamTable type="path">
                  {paramGroups.path.map((param) => (
                    <Param
                      name={param.name}
                      type={getSchemaType(param.schema)}
                      required={param.required}
                      enum={param.schema?.enum}
                    >
                      {param.description}
                    </Param>
                  ))}
                </ParamTable>
              )}

              <!-- Query Parameters -->
              {paramGroups.query.length > 0 && (
                <ParamTable type="query">
                  {paramGroups.query.map((param) => (
                    <Param
                      name={param.name}
                      type={getSchemaType(param.schema)}
                      required={param.required}
                      default={param.schema?.default?.toString()}
                      enum={param.schema?.enum}
                    >
                      {param.description}
                    </Param>
                  ))}
                </ParamTable>
              )}

              <!-- Header Parameters -->
              {paramGroups.header.length > 0 && (
                <ParamTable type="header">
                  {paramGroups.header.map((param) => (
                    <Param
                      name={param.name}
                      type={getSchemaType(param.schema)}
                      required={param.required}
                    >
                      {param.description}
                    </Param>
                  ))}
                </ParamTable>
              )}

              <!-- Request Body -->
              {requestContent?.schema && (
                <div class="request-body-section">
                  <h4 class="section-title">
                    <Icon name="lucide:file-input" size={16} />
                    Request Body
                    {endpoint.requestBody?.required && (
                      <span class="required-indicator">required</span>
                    )}
                  </h4>
                  <div class="schema-fields">
                    {requestContent.schema.properties && Object.entries(requestContent.schema.properties).map(([name, prop]: [string, any]) => (
                      <ResponseField
                        name={name}
                        type={getSchemaType(prop)}
                        required={requestContent.schema.required?.includes(name)}
                        nullable={prop.nullable}
                      >
                        {prop.description}
                      </ResponseField>
                    ))}
                  </div>
                </div>
              )}

              <!-- Response -->
              {successResponse && (
                <div class="response-section">
                  <h4 class="section-title">
                    <Icon name="lucide:file-output" size={16} />
                    Response
                  </h4>
                  {successResponse.content?.['application/json']?.schema && (
                    <div class="schema-fields">
                      {(() => {
                        const respSchema = successResponse.content['application/json'].schema;
                        const props = respSchema.properties || (respSchema.items?.properties);
                        if (!props) return null;
                        return Object.entries(props).map(([name, prop]: [string, any]) => (
                          <ResponseField
                            name={name}
                            type={getSchemaType(prop)}
                            nullable={prop.nullable}
                          >
                            {prop.description}
                          </ResponseField>
                        ));
                      })()}
                    </div>
                  )}
                </div>
              )}
            </APIEndpoint>

            <!-- API Playground -->
            {showPlayground && (
              <APIPlayground
                method={endpoint.method as any}
                path={endpoint.path}
                baseUrl={serverUrl}
                auth={auth}
              />
            )}
          </div>
        );
      })}
    </div>
  ))}
</div>

<style>
  @reference "../../styles/global.css";

  .openapi-spec {
    @apply space-y-8;
  }

  .spec-header {
    @apply p-6 rounded-xl border border-border bg-card;
    @apply mb-8;
    box-shadow: var(--shadow-sm);
  }

  .spec-info {
    @apply flex items-center gap-3 mb-2;
  }

  .spec-title {
    @apply text-2xl font-bold text-foreground m-0;
  }

  .spec-version {
    @apply px-2 py-1 text-xs font-mono font-semibold;
    @apply bg-primary-500/10 text-primary-600 rounded-md;
  }

  :global(.dark) .spec-version {
    @apply text-primary-400;
  }

  .spec-description {
    @apply text-muted-foreground text-sm leading-relaxed m-0 mb-3;
  }

  .spec-server {
    @apply inline-flex items-center gap-2 px-3 py-2;
    @apply text-sm font-mono text-muted-foreground;
    @apply bg-muted rounded-lg;
  }

  .spec-server code {
    @apply text-foreground;
  }

  .endpoint-group {
    @apply space-y-6;
  }

  .group-title {
    @apply flex items-center gap-2 text-lg font-semibold text-foreground;
    @apply mb-4 pb-2 border-b border-border;
  }

  .endpoint-wrapper {
    @apply space-y-4 mb-8;
  }

  .request-body-section,
  .response-section {
    @apply mt-4 pt-4 border-t border-border;
  }

  .section-title {
    @apply flex items-center gap-2 text-sm font-semibold text-foreground mb-3;
  }

  .required-indicator {
    @apply ml-2 px-1.5 py-0.5 text-[10px] font-semibold uppercase;
    @apply text-red-600 bg-red-500/10 rounded;
  }

  :global(.dark) .required-indicator {
    @apply text-red-400;
  }

  .schema-fields {
    @apply rounded-lg border border-border overflow-hidden;
  }
</style>
